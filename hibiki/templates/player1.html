{% load static %}
<link rel="stylesheet" href="{% static 'hibiki/css/player1.css' %}" />
{% comment %}
<script src="{% static 'hibiki/js/addToQueue.js' %}"></script>
{% endcomment %}
<!-- Player Overlay -->
<div class="player-overlay mini">
  <!-- Player View Toggle Btn -->
  <div class="view-toggle-div div1">
    <button id="view-toggle" class="view-toggle">‚õ∂</button>
  </div>

  <!-- Progress Bar -->
  <div class="player-bar div2">
    <input type="range" id="progress" min="0" max="100" value="0" />
    <div class="time-stamps">
      <span id="current-time">0:00</span> <span id="duration">0:00</span>
    </div>
  </div>

  <!-- Audio Controls -->
  <div class="audio-control-btn div3">
    <button id="prev">‚èÆ</button> <button id="play">‚ñ∂</button>
    <button id="next">‚è≠</button>
  </div>

  <!-- Volume Control -->
  <div class="volume-control div7">
    <button id="mute-btn" class="volume-icon">
      <span class="speaker"></span>
      <span class="speaker-square"></span>
      <span class="wave w1"></span>
      <span class="wave w2"></span>
      <span class="wave w3"></span>
      <span class="wave w4"></span>
      <span class="wave w5"></span>
    </button>

    <input type="range" id="volume" min="0" max="100" step="1" value="0" />
  </div>

  <!-- Track Info -->
  <div class="track-info-row div4">
    <img id="track-thumb" src="" alt="Thumbnail" />
    <div class="track-text">
      <h4 id="track-title">No song playing</h4>
      <p id="track-artists"></p>
    </div>
  </div>

  <div class="playlist-toggle-div div5">
    <button id="playlist-toggle">‚â°</button>
  </div>

  <!-- Playlist Drawer -->
  <div class="drawer div6" id="drawer">
    <div class="drawer-header">
      <h4>Playlist</h4>
      <button id="drawer-close">&times;</button>
    </div>
    <ul id="playlist" class="playlist"></ul>
  </div>

  <!-- Audio Tag  -->
  <audio id="audio"></audio>

  <!-- Playlist Modal -->
  <div id="playlistBackdropForPlayer" class="modal-backdrop-player">
    <div id="playlistmodalforplayer">
      <span class="close" onclick="closeModalForPlayer()">&times;</span>
      <h3>Your Playlists</h3>
      <ul id="playlistList_forPlayer"></ul>
      <p id="noPlaylists_forPlayer" style="display: none">
        No playlists found.
      </p>
    </div>
  </div>
</div>

<!-- ======================= JavaScript ======================= -->
<script>
  window.tracks = []
  window.currentIndex = 0

  const playerOverlay = document.querySelector(".player-overlay")
  const audio = document.getElementById("audio")
  const playBtn = document.getElementById("play")
  const progress = document.getElementById("progress")
  const currentTimeEl = document.getElementById("current-time")
  const durationEl = document.getElementById("duration")
  const titleEl = document.getElementById("track-title")
  const artistEl = document.getElementById("track-artists")
  const thumbnail = document.getElementById("track-thumb")
  const drawer = document.getElementById("drawer")
  const viewToggleBtn = document.getElementById("view-toggle")
  const mainContent = document.querySelector("main.main-section")

  viewToggleBtn.addEventListener("click", () => {
    playerOverlay.classList.toggle("fullscreen")
    playerOverlay.classList.toggle("mini")
    viewToggleBtn.textContent = playerOverlay.classList.contains("fullscreen")
      ? "üóï"
      : "‚õ∂"

    // Re-apply thumbnail size for current track
    if (window.tracks.length) {
      updateThumbnail(window.tracks[window.currentIndex])
    }
  })

  /* Drawer Toggle */
  document
    .getElementById("playlist-toggle")
    .addEventListener("click", () => drawer.classList.add("open"))
  document
    .getElementById("drawer-close")
    .addEventListener("click", () => drawer.classList.remove("open"))

  /* Helpers */
  function formatTime(time) {
    let min = Math.floor(time / 60)
    let sec = Math.floor(time % 60)
      .toString()
      .padStart(2, "0")
    return `${min}:${sec}`
  }

  function updatePlayerVisibility() {
    const hasTracks = window.tracks && window.tracks.length > 0

    // Show/hide player
    playerOverlay.style.display = hasTracks ? "grid" : "none"

    // ‚úÖ Add extra bottom padding only if player is visible
    mainContent.style.paddingBottom = hasTracks
      ? (playerOverlay.offsetHeight || 100) + "px"
      : "0px"
  }

  function updateThumbnail(track) {
    const lastThumb = track.thumbnails.at(-1)
    if (!lastThumb) return

    thumbnail.src = lastThumb.url

    if (playerOverlay.classList.contains("mini")) {
      // Mini view
      thumbnail.style.width = "50px"
      thumbnail.style.height = "50px"
    } else if (
      playerOverlay.classList.contains("fullscreen") &&
      lastThumb.width === lastThumb.height
    ) {
      // Fullscreen square thumbnail
      thumbnail.style.width = "255px"
      thumbnail.style.height = "255px"
    } else {
      // Fullscreen non-square thumbnail
      thumbnail.style.width = "100%"
      thumbnail.style.height = "400px"
    }
  }

  // Player Logic
  function savePlaylist() {
    if (window.tracks.length) {
      sessionStorage.setItem("playlistTracks", JSON.stringify(window.tracks))
      sessionStorage.setItem("playlistIndex", window.currentIndex)
      sessionStorage.setItem("playerTime", audio.currentTime)
      sessionStorage.setItem("playerPaused", audio.paused.toString())
    } else {
      sessionStorage.removeItem("playlistTracks")
      sessionStorage.removeItem("playlistIndex")
      sessionStorage.removeItem("playerTime")
      sessionStorage.removeItem("playerPaused")
    }
    updatePlayerVisibility()
  }

  function loadPlaylistFromStorage() {
    const storedTracks = sessionStorage.getItem("playlistTracks")
    const storedIndex = sessionStorage.getItem("playlistIndex")
    const storedTime = sessionStorage.getItem("playerTime")
    const storedPaused = sessionStorage.getItem("playerPaused")

    if (storedTracks) {
      window.tracks = JSON.parse(storedTracks)
      window.currentIndex = storedIndex ? parseInt(storedIndex) : 0

      if (window.tracks.length > 0) {
        loadTrackByData(window.tracks[window.currentIndex], false)
        populatePlaylist()

        // Restore playback time
        if (storedTime) {
          audio.currentTime = parseFloat(storedTime)
        }

        // Restore play/pause state after metadata is loaded
        audio.addEventListener("loadedmetadata", function restoreState() {
          if (storedPaused === "false") {
            audio.play().then(() => (playBtn.textContent = "‚è∏"))
          } else {
            playBtn.textContent = "‚ñ∂"
          }
          // Remove this listener after it's used
          audio.removeEventListener("loadedmetadata", restoreState)
        })
      }
    } else {
      window.tracks = []
    }
    updatePlayerVisibility()
  }

  function getCookie(name) {
    let cookieValue = null
    if (document.cookie && document.cookie !== "") {
      const cookies = document.cookie.split(";")
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim()
        // Check if this cookie starts with the name we want
        if (cookie.substring(0, name.length + 1) === name + "=") {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1))
          break
        }
      }
    }
    return cookieValue
  }

  function cacheNextTracks() {
    if (!window.tracks.length) return

    const nextTracks = window.tracks.slice(
      window.currentIndex + 1,
      window.currentIndex + 6
    )
    if (!nextTracks.length) return

    const ids = nextTracks.map((t) => t.videoId)

    console.log(ids)

    fetch("/precache_audio_urls/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCookie("csrftoken"), // If CSRF protection is on
      },
      body: JSON.stringify({video_ids: ids}),
    }).catch((err) => console.error("Cache request failed:", err))

    console.log("Cacheing request send")
  }

  function updateTimerUI(seconds) {
    currentTimeEl.textContent = formatTime(seconds)
  }
  function updateProgressBar(percentOrSeconds) {
    progress.value = percentOrSeconds // depending on your slider logic
  }

  function loadTrackByData(track, autoplay = false) {
    if (!track) return

    audio.pause()
    audio.src = ""
    audio.currentTime = 0
    audio.volume = 1 // default full volume

    updateTimerUI(0)
    updateProgressBar(0)

    playBtn.textContent = "‚ñ∂"

    titleEl.textContent = track.title
    artistEl.textContent = track.artists.map((a) => a.name).join(", ")
    thumbnail.src = track.thumbnails.at(-1).url
    thumbnail.alt = track.title

    //fetch(`/get_audio_url?video_id=${track.videoId}`)
    //  .then((res) => res.json())
    //  .then((data) => {
    //    if (data.audio_url) {
    //      audio.src = data.audio_url
    //      if (autoplay) {
    //        audio.play().then(() => (playBtn.textContent = "‚è∏"))
    //      }
    //    }
    //  })

    fetch(`/get_audio_url?video_id=${track.videoId}`)
      .then((res) => res.json())
      .then((data) => {
        if (data.audio_url) {
          audio.src = data.audio_url
          if (autoplay) {
            audio
              .play()
              .then(() => (playBtn.textContent = "‚è∏"))
              .catch((err) => {
                console.error("Playback failed:", err)
                const shortTitle = track.title.length > 10 ? track.title.slice(0, 10) + "..." : track.title;
                showToast(`‚ö†Ô∏è ${shortTitle.bold()} cannot be played right now due to a server issue. The same problem may occur with some other songs as well. We apologize for the inconvenience ‚Äî this will be fixed shortly. You can also report this issue if it continues.`)
                playNextTrack()
              })
          }
        } else {
          showToast("‚ö†Ô∏è No audio URL found, skipping...")
          playNextTrack()
        }
      })
      .catch((err) => {
        console.error("Fetch error:", err)
        showToast("‚ö†Ô∏è Failed to load song, skipping...")
        playNextTrack()
      })

    document
      .querySelectorAll("#playlist li")
      .forEach((li) => li.classList.remove("active"))
    const currentLi = document.querySelector(
      `#playlist li[data-index='${window.currentIndex}']`
    )
    if (currentLi) currentLi.classList.add("active")

    const volumeSlider = document.getElementById("volume")
    const muteBtn = document.getElementById("mute-btn")
    const waves = muteBtn.querySelectorAll(".wave")

    const savedVolume = sessionStorage.getItem("playerVolume")
    if (savedVolume !== null) {
      volumeSlider.value = savedVolume
      audio.volume = 1 - savedVolume / 100
    } else {
      audio.volume = 1
      volumeSlider.value = 0
    }
    updateWaves(audio.volume)
    updateSliderFill()

    function updateWaves(vol) {
      // vol is 0‚Äì1 ‚Üí map to 0‚Äì5 arcs
      let level = Math.round(vol * 5)
      waves.forEach((wave, i) => {
        wave.classList.toggle("active", i < level)
      })
    }

    // Update gradient fill of slider (inverse)
    function updateSliderFill() {
      let value = volumeSlider.value
      let percent = 100 - value // inverse
      volumeSlider.style.background = `linear-gradient(to right, white ${percent}%, #555 ${percent}%)`
    }

    volumeSlider.addEventListener("input", () => {
      audio.volume = 1 - volumeSlider.value / 100 // inverse
      audio.muted = audio.volume === 0
      updateWaves(audio.volume)
      updateSliderFill()

      sessionStorage.setItem("playerVolume", volumeSlider.value)
    })

    muteBtn.addEventListener("click", () => {
      if (audio.muted || audio.volume === 0) {
        audio.muted = false
        audio.volume = 1
        volumeSlider.value = 0
      } else {
        audio.muted = true
        audio.volume = 0
        volumeSlider.value = 100
      }
      updateWaves(audio.volume)
      updateSliderFill()
    })

    // Init
    updateWaves(audio.volume)
    updateSliderFill()

    updateThumbnail(track)
    savePlaylist()
    cacheNextTracks()
  }

  function playNextTrack() {
    if (!window.tracks.length) return
    window.currentIndex = (window.currentIndex + 1) % window.tracks.length
    loadTrackByData(window.tracks[window.currentIndex], true)
  }

  function player_playlist_menu_toggleFun(e, i) {
    e.stopPropagation() // Prevent click bubbling

    const menu = document.getElementById(`player-playlist-menu-listId-${i}`)
    const allMenus = document.querySelectorAll(".player-playlist-menu-list")

    // Close all other open menus
    allMenus.forEach((m) => {
      if (m !== menu) m.style.display = "none"
    })

    const isOpen = menu.style.display === "block"
    menu.style.display = isOpen ? "none" : "block"

    if (!isOpen) {
      // One-time outside click listener
      const closeOnOutsideClick = (event) => {
        if (!menu.contains(event.target)) {
          menu.style.display = "none"
          document.removeEventListener("click", closeOnOutsideClick)
        }
      }
      document.addEventListener("click", closeOnOutsideClick)

      // Close if the menu itself is clicked
      menu.onclick = (ev) => {
        ev.stopPropagation()
        menu.style.display = "none"
        document.removeEventListener("click", closeOnOutsideClick)
      }
    }
  }

  let add_track_fromPlayer
  const backdropForPlayer = document.getElementById("playlistBackdropForPlayer")

  //function closeModalForPlayer() {
  //  document.getElementById("playlistmodalforplayer").style.display = "none"
  //  if (!backdropForPlayer) return
  //  backdropForPlayer.classList.remove("open")
  //}

  function closeModalForPlayer() {
    const modal = document.getElementById("playlistmodalforplayer")
    if (modal) modal.style.display = "none"

    if (backdropForPlayer) {
      backdropForPlayer.classList.remove("open")
      backdropForPlayer.style.display = "none" // üîë added
    }
  }

  function addToPlaylistfromPlayer(e, inx) {
    e.stopPropagation()

    if (!isUserLoggedIn()) {
      showLoginPrompt()
      return
    }

    if (!backdropForPlayer) return console.error("playlistBackdrop not found")
    backdropForPlayer.classList.add("open")
    res = window.tracks[inx]

    // console.log(track)
    add_track_fromPlayer = res
    document.getElementById("playlistBackdropForPlayer").style.display = "flex"
    loadPlaylistsforPlayer()
  }

  function loadPlaylistsforPlayer() {
    fetch("/show-playlist/")
      .then((response) => response.json())
      .then((data) => {
        playlistList_forPlayer.innerHTML = ""

        if (!data.playlists || data.playlists.length === 0) {
          noPlaylists_forPlayer.style.display = "block"
          return
        }

        noPlaylists_forPlayer.style.display = "none"

        data.playlists.forEach((p) => {
          const li = document.createElement("li")
          li.textContent = `${p.name} (${p.total_songs} songs)`

          li.addEventListener("click", () => {
            playlistClickedfromPlayer(p.id, p.name)
          })

          playlistList_forPlayer.appendChild(li)
        })
      })
      .catch((err) => console.error("Error loading playlists:", err))
  }

  function playlistClickedfromPlayer(id, name) {
    fetch("/add_to_playlist/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        playlist_id: id,
        track: add_track_fromPlayer,
      }),
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.status === "success") {
          alert(`Track added to ${name}`)
          closeModalForPlayer() // optionally close modal after adding
        } else {
          alert(data.message || "Error adding track")
        }
      })
      .catch((err) => console.error(err))
    closeModalForPlayer() // optionally close modal after selection
  }

  function addToQueue(newTrack) {
    console.log(newTrack)

    let jsonStr = newTrack
      .replace(/"/g, "ÔºÇ") // different unicode double qoute(ÔºÇ)
      .replace(/'/g, '"')
      .replace(/\bFalse\b/g, "false")
      .replace(/\bTrue\b/g, "true")
      .replace(/\bNone\b/g, "null")

    console.log(jsonStr)
    // Parse into JS object
    let obj = JSON.parse(jsonStr)

    // IF THERE IS NO TRACKS ARRAY
    if (!window.tracks || window.tracks.length === 0) {
      window.tracks.push(obj)
      loadTrackByData(obj, true)
    } else {
      window.tracks.push(obj)
    }

    //console.log(window.tracks)
    populatePlaylist()
    savePlaylist()
  }

  function copyShareableLink(songId) {
    //e.stopPropagation()

    console.log("copyShareableLink: ", songId)

    if (!songId) {
      alert("No song ID provided!")
      return
    }
    const baseUrl = window.location.origin + "/home/"
    const shareUrl = `${baseUrl}?songId=${encodeURIComponent(songId)}`
    // Copy to clipboard
    navigator.clipboard
      .writeText(shareUrl)
      .then(() => {
        alert("Link copied to clipboard!")
      })
      .catch((err) => {
        console.error("Failed to copy link:", err)
        alert("Failed to copy link")
      })
  }

  function populatePlaylist() {
    console.log("populate")
    const ul = document.getElementById("playlist")
    ul.innerHTML = ""

    window.tracks.forEach((track, i) => {
      const li = document.createElement("li")
      li.dataset.index = i
      li.innerHTML = `
        <div class="player-playlist-item">
    <img src="${track.thumbnails[0].url}" alt="${track.title}" />
    <div class="track-info">
        <h4>${track.title}</h4>
        <p>${track.artists.map((a) => a.name).join(", ")}</p>
    </div>
    <div class="player-playlist-menu">
      <button class="player-playlist-menu-btn" onclick="player_playlist_menu_toggleFun(event,${i})">‚ãÆ</button>
      <div class="player-playlist-menu-list" id="player-playlist-menu-listId-${i}" style="display:none;">
        <ul>
          <li onclick="addToPlaylistfromPlayer(event,${i})">Add to Playlist</li>
          <li onclick="event.stopPropagation(); copyShareableLink('${
            track.videoId
          }')">Share</li>
        </ul>
      </div>
    </div>
  </div>
  `

      // üîπ Highlight the current track
      if (i === window.currentIndex) {
        li.classList.add("active")
      }

      ul.appendChild(li)
    })
  }

  /* Global play function */
  window.playSongId = function (videoId) {
    fetch(`/api/player/?songId=${videoId}`)
      .then((res) => res.json())
      .then((data) => {
        if (data.tracks && data.tracks.length) {
          window.tracks = data.tracks
          window.currentIndex = 0
          loadTrackByData(window.tracks[0], true)
          populatePlaylist()
        }
        console.log(data)
      })
  }

  /* Controls */
  playBtn.addEventListener("click", () => {
    if (audio.paused) {
      audio.play().then(() => (playBtn.textContent = "‚è∏"))
    } else {
      audio.pause()
      playBtn.textContent = "‚ñ∂"
    }
  })

  document.getElementById("next").addEventListener("click", playNextTrack)

  document.getElementById("prev").addEventListener("click", () => {
    if (!window.tracks.length) return
    window.currentIndex =
      (window.currentIndex - 1 + window.tracks.length) % window.tracks.length
    loadTrackByData(window.tracks[window.currentIndex], true)
  })

  /* Audio Events */
  audio.addEventListener("timeupdate", () => {
    if (!isNaN(audio.duration)) {
      progress.value = (audio.currentTime / audio.duration) * 100
      currentTimeEl.textContent = formatTime(audio.currentTime)
    }
  })
  audio.addEventListener("loadedmetadata", () => {
    durationEl.textContent = formatTime(audio.duration)
  })
  audio.addEventListener("ended", playNextTrack)

  audio.addEventListener("timeupdate", savePlaylist)
  audio.addEventListener("play", savePlaylist)
  audio.addEventListener("pause", savePlaylist)

  /* Seek */
  progress.addEventListener("input", (e) => {
    audio.currentTime = (e.target.value / 100) * audio.duration
  })

  /* Playlist click */
  document.getElementById("playlist").addEventListener("click", (e) => {
    const li = e.target.closest("li")
    if (li && window.tracks.length > 0) {
      window.currentIndex = parseInt(li.dataset.index)
      loadTrackByData(window.tracks[window.currentIndex], true)
      // drawer.classList.remove("open")
    }
  })

  /* Load on page start */
  document.addEventListener("DOMContentLoaded", loadPlaylistFromStorage)
</script>
