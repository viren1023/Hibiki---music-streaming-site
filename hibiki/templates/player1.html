{% load static %}
<link rel="stylesheet" href="{% static 'hibiki/css/player1.css' %}" />
{% comment %}
<script src="{% static 'hibiki/js/addToQueue.js' %}"></script>
{% endcomment %}
<!-- Player Overlay -->
<div class="player-overlay mini">
  <!-- Player View Toggle Btn -->
  <div class="view-toggle-div div1">
    <button id="view-toggle" class="view-toggle">‚õ∂</button>
  </div>

  <!-- Progress Bar -->
  <div class="player-bar div2">
    <input type="range" id="progress" min="0" max="100" value="0" />
    <div class="time-stamps">
      <span id="current-time">0:00</span> <span id="duration">0:00</span>
    </div>
  </div>

  <!-- Audio Controls -->
  <div class="audio-control-btn div3">
    <button id="prev">‚èÆ</button> <button id="play">‚ñ∂</button>
    <button id="next">‚è≠</button>
  </div>

  <!-- Track Info -->
  <div class="track-info-row div4">
    <img id="track-thumb" src="" alt="Thumbnail" />
    <div class="track-text">
      <h4 id="track-title">No song playing</h4>
      <p id="track-artists"></p>
    </div>
  </div>

  <div class="playlist-toggle-div div5">
    <button id="playlist-toggle">‚â°</button>
  </div>

  <!-- Playlist Drawer -->
  <div class="drawer div6" id="drawer">
    <div class="drawer-header">
      <h4>Playlist</h4>
      <button id="drawer-close">&times;</button>
    </div>
    <ul id="playlist" class="playlist"></ul>
  </div>

  <!-- Audio Tag  -->
  <audio id="audio"></audio>

  <!-- Playlist Modal -->
  <div id="playlistBackdropForPlayer" class="modal-backdrop-player">
    <div id="playlistmodalforplayer">
      <span class="close" onclick="closeModalForPlayer()">&times;</span>
      <h3>Your Playlists</h3>
      <ul id="playlistList_forPlayer"></ul>
      <p id="noPlaylists_forPlayer" style="display: none">
        No playlists found.
      </p>
    </div>
  </div>
</div>

<!-- ======================= JavaScript ======================= -->
<script>
  window.tracks = []
  window.currentIndex = 0

  const playerOverlay = document.querySelector(".player-overlay")
  const audio = document.getElementById("audio")
  const playBtn = document.getElementById("play")
  const progress = document.getElementById("progress")
  const currentTimeEl = document.getElementById("current-time")
  const durationEl = document.getElementById("duration")
  const titleEl = document.getElementById("track-title")
  const artistEl = document.getElementById("track-artists")
  const thumbnail = document.getElementById("track-thumb")
  const drawer = document.getElementById("drawer")
  const viewToggleBtn = document.getElementById("view-toggle")

  viewToggleBtn.addEventListener("click", () => {
    playerOverlay.classList.toggle("fullscreen")
    playerOverlay.classList.toggle("mini")
    viewToggleBtn.textContent = playerOverlay.classList.contains("fullscreen")
      ? "üóï"
      : "‚õ∂"

    // Re-apply thumbnail size for current track
    if (window.tracks.length) {
      updateThumbnail(window.tracks[window.currentIndex])
    }
  })

  /* Drawer Toggle */
  document
    .getElementById("playlist-toggle")
    .addEventListener("click", () => drawer.classList.add("open"))
  document
    .getElementById("drawer-close")
    .addEventListener("click", () => drawer.classList.remove("open"))

  /* Helpers */
  function formatTime(time) {
    let min = Math.floor(time / 60)
    let sec = Math.floor(time % 60)
      .toString()
      .padStart(2, "0")
    return `${min}:${sec}`
  }

  function updatePlayerVisibility() {
    playerOverlay.style.display =
      !window.tracks || window.tracks.length === 0 ? "none" : "grid"
  }

  function updateThumbnail(track) {
    const lastThumb = track.thumbnails.at(-1)
    if (!lastThumb) return

    thumbnail.src = lastThumb.url

    if (playerOverlay.classList.contains("mini")) {
      // Mini view
      thumbnail.style.width = "50px"
      thumbnail.style.height = "50px"
    } else if (
      playerOverlay.classList.contains("fullscreen") &&
      lastThumb.width === lastThumb.height
    ) {
      // Fullscreen square thumbnail
      thumbnail.style.width = "255px"
      thumbnail.style.height = "255px"
    } else {
      // Fullscreen non-square thumbnail
      thumbnail.style.width = "100%"
      thumbnail.style.height = "auto"
    }
  }

  // Player Logic
  function savePlaylist() {
    if (window.tracks.length) {
      localStorage.setItem("playlistTracks", JSON.stringify(window.tracks))
      localStorage.setItem("playlistIndex", window.currentIndex)
      localStorage.setItem("playerTime", audio.currentTime)
      localStorage.setItem("playerPaused", audio.paused.toString())
    } else {
      localStorage.removeItem("playlistTracks")
      localStorage.removeItem("playlistIndex")
      localStorage.removeItem("playerTime")
      localStorage.removeItem("playerPaused")
    }
    updatePlayerVisibility()
  }

  function loadPlaylistFromStorage() {
    const storedTracks = localStorage.getItem("playlistTracks")
    const storedIndex = localStorage.getItem("playlistIndex")
    const storedTime = localStorage.getItem("playerTime")
    const storedPaused = localStorage.getItem("playerPaused")

    if (storedTracks) {
      window.tracks = JSON.parse(storedTracks)
      window.currentIndex = storedIndex ? parseInt(storedIndex) : 0

      if (window.tracks.length > 0) {
        loadTrackByData(window.tracks[window.currentIndex], false)
        populatePlaylist()

        // Restore playback time
        if (storedTime) {
          audio.currentTime = parseFloat(storedTime)
        }

        // Restore play/pause state after metadata is loaded
        audio.addEventListener("loadedmetadata", function restoreState() {
          if (storedPaused === "false") {
            audio.play().then(() => (playBtn.textContent = "‚è∏"))
          } else {
            playBtn.textContent = "‚ñ∂"
          }
          // Remove this listener after it's used
          audio.removeEventListener("loadedmetadata", restoreState)
        })
      }
    } else {
      window.tracks = []
    }
    updatePlayerVisibility()
  }

  function getCookie(name) {
    let cookieValue = null
    if (document.cookie && document.cookie !== "") {
      const cookies = document.cookie.split(";")
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim()
        // Check if this cookie starts with the name we want
        if (cookie.substring(0, name.length + 1) === name + "=") {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1))
          break
        }
      }
    }
    return cookieValue
  }

  function cacheNextTracks() {
    if (!window.tracks.length) return

    const nextTracks = window.tracks.slice(
      window.currentIndex + 1,
      window.currentIndex + 6
    )
    if (!nextTracks.length) return

    const ids = nextTracks.map((t) => t.videoId)

    console.log(ids)

    fetch("/precache_audio_urls/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCookie("csrftoken"), // If CSRF protection is on
      },
      body: JSON.stringify({video_ids: ids}),
    }).catch((err) => console.error("Cache request failed:", err))

    console.log("Cacheing request send")
  }

  function loadTrackByData(track, autoplay = false) {
    if (!track) return

    audio.pause()
    audio.src = ""
    audio.currentTime = 0
    playBtn.textContent = "‚ñ∂"

    titleEl.textContent = track.title
    artistEl.textContent = track.artists.map((a) => a.name).join(", ")
    thumbnail.src = track.thumbnails.at(-1).url
    thumbnail.alt = track.title

    fetch(`/get_audio_url?video_id=${track.videoId}`)
      .then((res) => res.json())
      .then((data) => {
        if (data.audio_url) {
          audio.src = data.audio_url
          if (autoplay) {
            audio.play().then(() => (playBtn.textContent = "‚è∏"))
          }
        }
      })

    document
      .querySelectorAll("#playlist li")
      .forEach((li) => li.classList.remove("active"))
    const currentLi = document.querySelector(
      `#playlist li[data-index='${window.currentIndex}']`
    )
    if (currentLi) currentLi.classList.add("active")

    updateThumbnail(track)
    savePlaylist()

    cacheNextTracks()
  }

  function player_playlist_menu_toggleFun(e, i) {
    e.stopPropagation()
    const player_playlist_menu = document.getElementById(
      `player-playlist-menu-listId-${i}`
    )
    const player_playlist_allMenus = document.querySelectorAll(
      ".player-playlist-menu-list"
    )
    player_playlist_allMenus.forEach((m) => {
      if (m !== player_playlist_menu) m.style.display = "none"
    })
    player_playlist_menu.style.display =
      player_playlist_menu.style.display === "block" ? "none" : "block"
  }

  let add_track_fromPlayer
  const backdropForPlayer = document.getElementById("playlistBackdropForPlayer")

  //function closeModalForPlayer() {
  //  document.getElementById("playlistmodalforplayer").style.display = "none"
  //  if (!backdropForPlayer) return
  //  backdropForPlayer.classList.remove("open")
  //}

  function closeModalForPlayer() {
    const modal = document.getElementById("playlistmodalforplayer")
    if (modal) modal.style.display = "none"

    if (backdropForPlayer) {
      backdropForPlayer.classList.remove("open")
      backdropForPlayer.style.display = "none" // üîë added
    }
  }

  function addToPlaylistfromPlayer(e, inx) {
    e.stopPropagation()
    if (!backdropForPlayer) return console.error("playlistBackdrop not found")
    backdropForPlayer.classList.add("open")
    res = window.tracks[inx]

    // console.log(track)
    add_track_fromPlayer = res
    document.getElementById("playlistBackdropForPlayer").style.display = "flex"
    loadPlaylistsforPlayer()
  }

  function loadPlaylistsforPlayer() {
    fetch("/show-playlist/")
      .then((response) => response.json())
      .then((data) => {
        playlistList_forPlayer.innerHTML = ""

        if (!data.playlists || data.playlists.length === 0) {
          noPlaylists_forPlayer.style.display = "block"
          return
        }

        noPlaylists_forPlayer.style.display = "none"

        data.playlists.forEach((p) => {
          const li = document.createElement("li")
          li.textContent = `${p.name} (${p.total_songs} songs)`

          li.addEventListener("click", () => {
            playlistClickedfromPlayer(p.id, p.name)
          })

          playlistList_forPlayer.appendChild(li)
        })
      })
      .catch((err) => console.error("Error loading playlists:", err))
  }

  function playlistClickedfromPlayer(id, name) {
    fetch("/add_to_playlist/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        playlist_id: id,
        track: add_track_fromPlayer,
      }),
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.status === "success") {
          alert(`Track added to ${name}`)
          closeModalForPlayer() // optionally close modal after adding
        } else {
          alert(data.message || "Error adding track")
        }
      })
      .catch((err) => console.error(err))
    closeModalForPlayer() // optionally close modal after selection
  }

  function addToQueue(newTrack) {
    console.log(newTrack)

    let jsonStr = newTrack
      .replace(/"/g, "ÔºÇ") // different unicode double qoute(ÔºÇ)
      .replace(/'/g, '"')
      .replace(/\bFalse\b/g, "false")
      .replace(/\bTrue\b/g, "true")
      .replace(/\bNone\b/g, "null")

    console.log(jsonStr)
    // Parse into JS object
    let obj = JSON.parse(jsonStr)
    window.tracks.push(obj)
    console.log(window.tracks)
    populatePlaylist()
    savePlaylist()
  }

  function addToQueue1() {
    console.log("fick u")
  }

  function populatePlaylist() {
    console.log("populate")
    const ul = document.getElementById("playlist")
    ul.innerHTML = ""

    window.tracks.forEach((track, i) => {
      const li = document.createElement("li")
      li.dataset.index = i
      li.innerHTML = `
        <div class="player-playlist-item">
    <img src="${track.thumbnails[0].url}" alt="${track.title}" />
    <div class="track-info">
        <h4>${track.title}</h4>
        <p>${track.artists.map((a) => a.name).join(", ")}</p>
    </div>
    <div class="player-playlist-menu">
      <button class="player-playlist-menu-btn" onclick="player_playlist_menu_toggleFun(event,${i})">‚ãÆ</button>
      <div class="player-playlist-menu-list" id="player-playlist-menu-listId-${i}" style="display:none;">
        <ul>
          <li onclick="addToQueue(event,${i})" >Add to Queue</li>
          <li onclick="addToPlaylistfromPlayer(event,${i})">Add to Playlist</li>
          <li>Share</li>
        </ul>
      </div>
    </div>
  </div>
  `

      // üîπ Highlight the current track
      if (i === window.currentIndex) {
        li.classList.add("active")
      }

      ul.appendChild(li)
    })
  }

  /* Global play function */
  window.playSongId = function (videoId) {
    fetch(`/api/player/?songId=${videoId}`)
      .then((res) => res.json())
      .then((data) => {
        if (data.tracks && data.tracks.length) {
          window.tracks = data.tracks
          window.currentIndex = 0
          loadTrackByData(window.tracks[0], true)
          populatePlaylist()
        }
        console.log(data)
      })
  }

  /* Controls */
  playBtn.addEventListener("click", () => {
    if (audio.paused) {
      audio.play().then(() => (playBtn.textContent = "‚è∏"))
    } else {
      audio.pause()
      playBtn.textContent = "‚ñ∂"
    }
  })

  document.getElementById("next").addEventListener("click", () => {
    if (!window.tracks.length) return
    window.currentIndex = (window.currentIndex + 1) % window.tracks.length
    loadTrackByData(window.tracks[window.currentIndex], true)
  })

  document.getElementById("prev").addEventListener("click", () => {
    if (!window.tracks.length) return
    window.currentIndex =
      (window.currentIndex - 1 + window.tracks.length) % window.tracks.length
    loadTrackByData(window.tracks[window.currentIndex], true)
  })

  /* Audio Events */
  audio.addEventListener("timeupdate", () => {
    if (!isNaN(audio.duration)) {
      progress.value = (audio.currentTime / audio.duration) * 100
      currentTimeEl.textContent = formatTime(audio.currentTime)
    }
  })
  audio.addEventListener("loadedmetadata", () => {
    durationEl.textContent = formatTime(audio.duration)
  })
  audio.addEventListener("ended", () => {
    if (!window.tracks.length) return
    window.currentIndex = (window.currentIndex + 1) % window.tracks.length
    loadTrackByData(window.tracks[window.currentIndex], true)
  })

  audio.addEventListener("timeupdate", savePlaylist)
  audio.addEventListener("play", savePlaylist)
  audio.addEventListener("pause", savePlaylist)

  /* Seek */
  progress.addEventListener("input", (e) => {
    audio.currentTime = (e.target.value / 100) * audio.duration
  })

  /* Playlist click */
  document.getElementById("playlist").addEventListener("click", (e) => {
    const li = e.target.closest("li")
    if (li && window.tracks.length > 0) {
      window.currentIndex = parseInt(li.dataset.index)
      loadTrackByData(window.tracks[window.currentIndex], true)
      // drawer.classList.remove("open")
    }
  })

  /* Load on page start */
  document.addEventListener("DOMContentLoaded", loadPlaylistFromStorage)
</script>
